# 索引(一种便于检索的数据结构)
+ 创建索引|CREATE INDEX
	1. 基本格式:
	```
	CREATE [UNIQUE][CLUSTERED|NONCLUSTERED] INDEX<索引名>
	ON <表名|视图名>(<列名清单>);
	```
	2. 说明:
	```
	<列名清单>中，每个列名要制定升序(ASC)或降序(DESC)(默认为升序)
	UNIQUE:规定索引的每一个索引值只对应表或视图中唯一的记录，允许NULL且NULL不能有多个。
	CLUSTERED:聚簇索引，唯一。(默认为NONCLUSTERED)

	```
	3. 示例：
	```
	# 为职工表建立索引，首先以部门号Dno升序排序，部门号相同时在以职工号Eno降序排序。
	CREATE INDEX IDX_Emp
	ON Employee(Dno,Eno DESC);
	```
	---
+ 删除索引|DROP INDEX
	1. 基本格式:
	```
	DROP INDEX <索引名>
	ON <表名|视图名>;
	```
	2. 示例：
	```
	# 删除索引
	#DROP INDEX `IDX_Emp` ON `Employee`;
	```
	---
+ 适合建立索引的情况
	1. 关系的主码或外部码属性
	2. 经常在查询中用到的属性，如经常在WHERE句子中出现的属性
	3. 经常在ORDER BY子句中使用的属性
	4. 频繁出现在连接条件中的属性
	5. 经常在范围查询(=、>、<、>=、<=)中用到的属性
	6. 使用聚集函数(MAX MIN AVG SUM COUNT)用到或需要排序输出的属性
+ 不适合建立索引的情况
	1. 在查询中很少被用到的属性
	2. 经常插入，删除和更新的属性
	3. 取值很少的属性(如性别)
	4. 特殊数据类型的属性不能建立索引(BIT,TEXT,IMAGE)
	5. 表太小
	6. 过长的属性
+ 建立索引的优缺点
	+ 优点：索引是改善存取路径的重要手段，大大减少了CPU和I/O服务时间对某个属性建立索引后，
	数据库会对该属性上的值进行排序就可以使用二分查找算法(log2N)实现对该属性上值的检索，在较大数据量的情况下相比未建立索引时的顺序扫描(N)的情况检索效率得到极大地提高，同时也可以加快表的连接。
	+ 缺点：对表上某个属性建立索引需要增加额外的存储开销同时
	使得对表的数据插入，删除和更新变得复杂费时。
	
	
### 聚簇索引(Clustered Index)
---
聚簇索引的顺序就是数据的物理存储顺序，一张表只有一个聚簇索引。

### Mysql索引数据结构
+ B+ 树索引
+ 哈希索引
### 资料
---
+ [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

